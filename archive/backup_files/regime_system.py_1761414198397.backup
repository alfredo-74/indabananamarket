"""
Complete Automated Order Flow Trading System - ALL IN ONE
Includes:
- Regime Detection (Rotational vs Directional)
- VWAP + Standard Deviations
- Divergence Analysis
- AUTOMATIC EXECUTION ENGINE
- Multi-strategy selection
- NY session filtering
"""

import numpy as np
import pandas as pd
from datetime import datetime, time, timedelta
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
from enum import Enum
from collections import deque

# ============================================================================
# ENUMS & DATA STRUCTURES
# ============================================================================

class MarketRegime(Enum):
    """Regime di giornata"""
    ROTATIONAL = "Rotational"
    DIRECTIONAL_BULLISH = "Directional Bullish"
    DIRECTIONAL_BEARISH = "Directional Bearish"
    TRANSITIONING = "Transitioning"

class TradingStrategy(Enum):
    """Strategie disponibili"""
    SCALPING = "Scalping"
    MOMENTUM = "Momentum"
    MEAN_REVERSION = "Mean Reversion"
    BREAKOUT = "Breakout"

class DivergenceType(Enum):
    """Tipi di divergenza"""
    BULLISH_REGULAR = "Bullish Regular"
    BEARISH_REGULAR = "Bearish Regular"
    BULLISH_HIDDEN = "Bullish Hidden"
    BEARISH_HIDDEN = "Bearish Hidden"
    ABSORPTION_BULLISH = "Absorption Bullish"
    ABSORPTION_BEARISH = "Absorption Bearish"
    NONE = "No Divergence"

class TradeStatus(Enum):
    """Stato trade"""
    OPEN = "Open"
    CLOSED = "Closed"

@dataclass
class OrderFlowSnapshot:
    """Snapshot mercato"""
    timestamp: datetime
    price: float
    cumulative_delta: float
    bid_volume: Dict[float, float]
    ask_volume: Dict[float, float]
    volume: float
    vwap: Optional[float] = None

@dataclass
class Divergence:
    """Divergenza rilevata"""
    divergence_type: DivergenceType
    confidence: float
    start_time: datetime
    end_time: datetime
    price_change: float
    cd_change: float
    description: str
    price_level_1: float
    price_level_2: float

@dataclass
class AutoTrade:
    """Trade automatico"""
    entry_time: datetime
    entry_price: float
    direction: str
    contracts: int
    stop_loss: float
    take_profit: float
    signal_type: str
    confidence: float
    status: TradeStatus = TradeStatus.OPEN
    exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    exit_reason: str = ''
    pnl: float = 0.0

# ============================================================================
# VWAP SYSTEM
# ============================================================================

class VWAPSystem:
    """VWAP con standard deviations"""
    
    def __init__(self, tick_size: float = 0.25, std_dev_ticks: int = 70):
        self.tick_size = tick_size
        self.std_dev_points = std_dev_ticks * tick_size
        self.prices = deque(maxlen=1000)
        self.volumes = deque(maxlen=1000)
        self.vwap_history = deque(maxlen=100)
        self.current_vwap = None
        self.upper_std1 = None
        self.lower_std1 = None
        self.upper_std2 = None
        self.lower_std2 = None
    
    def add_data(self, timestamp: datetime, price: float, volume: float):
        self.prices.append(price)
        self.volumes.append(volume)
        self._calculate_vwap()
        self._calculate_std_devs()
    
    def _calculate_vwap(self):
        if len(self.prices) == 0:
            return
        total_pv = sum(p * v for p, v in zip(self.prices, self.volumes))
        total_v = sum(self.volumes)
        self.current_vwap = total_pv / (total_v + 1e-6)
        self.vwap_history.append(self.current_vwap)
    
    def _calculate_std_devs(self):
        if self.current_vwap is None:
            return
        self.upper_std1 = self.current_vwap + self.std_dev_points
        self.lower_std1 = self.current_vwap - self.std_dev_points
        self.upper_std2 = self.current_vwap + (self.std_dev_points * 2)
        self.lower_std2 = self.current_vwap - (self.std_dev_points * 2)
    
    def calculate_vwap_slope(self, lookback_bars: int = 20) -> float:
        if len(self.vwap_history) < lookback_bars:
            return 0.0
        recent_vwap = list(self.vwap_history)[-lookback_bars:]
        x = np.arange(len(recent_vwap))
        slope, _ = np.polyfit(x, recent_vwap, 1)
        vwap_range = max(recent_vwap) - min(recent_vwap)
        normalized_slope = (slope * len(recent_vwap)) / (vwap_range + 1e-6)
        return normalized_slope
    
    def get_levels_dict(self) -> Dict[str, float]:
        return {
            'vwap': self.current_vwap,
            'upper_std1': self.upper_std1,
            'lower_std1': self.lower_std1,
            'upper_std2': self.upper_std2,
            'lower_std2': self.lower_std2
        }

# ============================================================================
# REGIME DETECTOR
# ============================================================================

class RegimeDetector:
    """Identifica regime giornaliero"""
    
    def __init__(self, vwap_system: VWAPSystem):
        self.vwap_system = vwap_system
        self.cd_history = deque(maxlen=100)
        self.price_history = deque(maxlen=100)
    
    def add_data(self, price: float, cumulative_delta: float):
        self.price_history.append(price)
        self.cd_history.append(cumulative_delta)
    
    def detect_regime(self) -> Tuple[MarketRegime, float, str]:
        if len(self.cd_history) < 20:
            return MarketRegime.TRANSITIONING, 0.3, "Dati insufficienti"
        
        vwap_slope = self.vwap_system.calculate_vwap_slope(20)
        recent_cd = list(self.cd_history)[-20:]
        cd_change = recent_cd[-1] - recent_cd[0]
        cd_normalized = cd_change / (abs(recent_cd[0]) + 1000)
        
        recent_prices = list(self.price_history)[-50:]
        price_range = max(recent_prices) - min(recent_prices)
        price_range_pct = (price_range / self.vwap_system.current_vwap) * 100
        
        # DIRECTIONAL BULLISH
        if vwap_slope > 0.3 and cd_normalized > 0.2:
            return MarketRegime.DIRECTIONAL_BULLISH, min(0.90, 0.6 + abs(vwap_slope) + abs(cd_normalized)), \
                   f"VWAP +{vwap_slope:.2f}, CD +{cd_change:+.0f}. Directional UP"
        
        # DIRECTIONAL BEARISH
        elif vwap_slope < -0.3 and cd_normalized < -0.2:
            return MarketRegime.DIRECTIONAL_BEARISH, min(0.90, 0.6 + abs(vwap_slope) + abs(cd_normalized)), \
                   f"VWAP {vwap_slope:.2f}, CD {cd_change:+.0f}. Directional DOWN"
        
        # ROTATIONAL
        elif abs(vwap_slope) < 0.2 and price_range_pct < 0.8:
            return MarketRegime.ROTATIONAL, min(0.85, 0.6 + (0.2 - abs(vwap_slope)) * 2), \
                   f"VWAP flat, range {price_range_pct:.2f}%. Rotational"
        
        return MarketRegime.TRANSITIONING, 0.4, "Segnali misti"

# ============================================================================
# DIVERGENCE ANALYZER
# ============================================================================

class DivergenceAnalyzer:
    """Analizza divergenze Price vs CD"""
    
    def __init__(self, lookback_swing: int = 10, absorption_threshold: float = 200.0):
        self.lookback_swing = lookback_swing
        self.absorption_threshold = absorption_threshold
        self.price_history = deque(maxlen=100)
        self.cd_history = deque(maxlen=100)
        self.timestamp_history = deque(maxlen=100)
        self.swing_highs = deque(maxlen=20)
        self.swing_lows = deque(maxlen=20)
    
    def add_data(self, timestamp: datetime, price: float, cumulative_delta: float):
        self.price_history.append(price)
        self.cd_history.append(cumulative_delta)
        self.timestamp_history.append(timestamp)
        if len(self.price_history) >= self.lookback_swing:
            self._identify_swing_points()
    
    def _identify_swing_points(self):
        if len(self.price_history) < self.lookback_swing * 2:
            return
        lookback = self.lookback_swing
        prices = list(self.price_history)
        cds = list(self.cd_history)
        timestamps = list(self.timestamp_history)
        center = len(prices) - lookback - 1
        
        if center > lookback:
            window = prices[center - lookback:center + lookback + 1]
            center_price = prices[center]
            
            if center_price == max(window):
                self.swing_highs.append((timestamps[center], center_price, cds[center]))
            if center_price == min(window):
                self.swing_lows.append((timestamps[center], center_price, cds[center]))
    
    def detect_regular_bullish_divergence(self) -> Optional[Divergence]:
        """Price LL, CD HL â†’ Reversal UP"""
        if len(self.swing_lows) < 2:
            return None
        low1_time, low1_price, low1_cd = self.swing_lows[-2]
        low2_time, low2_price, low2_cd = self.swing_lows[-1]
        
        if low2_price < low1_price and low2_cd > low1_cd:
            strength = min(1.0, abs(low2_price - low1_price) / low1_price * 100)
            return Divergence(
                divergence_type=DivergenceType.BULLISH_REGULAR,
                confidence=0.65 + strength * 0.25,
                start_time=low1_time,
                end_time=low2_time,
                price_change=low2_price - low1_price,
                cd_change=low2_cd - low1_cd,
                description=f"Bullish Divergence: Price LL but CD HL. Reversal UP probable",
                price_level_1=low1_price,
                price_level_2=low2_price
            )
        return None
    
    def detect_regular_bearish_divergence(self) -> Optional[Divergence]:
        """Price HH, CD LH â†’ Reversal DOWN"""
        if len(self.swing_highs) < 2:
            return None
        high1_time, high1_price, high1_cd = self.swing_highs[-2]
        high2_time, high2_price, high2_cd = self.swing_highs[-1]
        
        if high2_price > high1_price and high2_cd < high1_cd:
            strength = min(1.0, abs(high2_price - high1_price) / high1_price * 100)
            return Divergence(
                divergence_type=DivergenceType.BEARISH_REGULAR,
                confidence=0.65 + strength * 0.25,
                start_time=high1_time,
                end_time=high2_time,
                price_change=high2_price - high1_price,
                cd_change=high2_cd - high1_cd,
                description=f"Bearish Divergence: Price HH but CD LH. Reversal DOWN probable",
                price_level_1=high1_price,
                price_level_2=high2_price
            )
        return None
    
    def detect_realtime_absorption(self) -> Optional[Divergence]:
        """Absorption intrabar"""
        if len(self.price_history) < 10:
            return None
        recent_prices = list(self.price_history)[-10:]
        recent_cds = list(self.cd_history)[-10:]
        recent_times = list(self.timestamp_history)[-10:]
        
        price_change = recent_prices[-1] - recent_prices[0]
        cd_change = recent_cds[-1] - recent_cds[0]
        
        # Bullish Absorption
        if price_change < -2 and cd_change > -self.absorption_threshold:
            return Divergence(
                divergence_type=DivergenceType.ABSORPTION_BULLISH,
                confidence=0.60,
                start_time=recent_times[0],
                end_time=recent_times[-1],
                price_change=price_change,
                cd_change=cd_change,
                description="Bullish Absorption: Price down but CD stable. Bounce probable",
                price_level_1=recent_prices[0],
                price_level_2=recent_prices[-1]
            )
        
        # Bearish Absorption
        elif price_change > 2 and cd_change < self.absorption_threshold:
            return Divergence(
                divergence_type=DivergenceType.ABSORPTION_BEARISH,
                confidence=0.60,
                start_time=recent_times[0],
                end_time=recent_times[-1],
                price_change=price_change,
                cd_change=cd_change,
                description="Bearish Absorption: Price up but CD stable. Reversal probable",
                price_level_1=recent_prices[0],
                price_level_2=recent_prices[-1]
            )
        return None
    
    def detect_all_divergences(self) -> List[Divergence]:
        """Rileva tutte le divergenze"""
        divergences = []
        for method in [self.detect_regular_bullish_divergence,
                      self.detect_regular_bearish_divergence,
                      self.detect_realtime_absorption]:
            div = method()
            if div:
                divergences.append(div)
        divergences.sort(key=lambda x: x.confidence, reverse=True)
        return divergences

# ============================================================================
# AUTOMATED EXECUTION ENGINE
# ============================================================================

class AutomatedExecutionEngine:
    """Engine esecuzione automatica"""
    
    def __init__(
        self,
        initial_capital: float = 10000.0,
        risk_per_trade_pct: float = 1.0,
        max_open_positions: int = 1,
        auto_trade_enabled: bool = True,
        min_confidence: float = 0.70,
        point_value: float = 5.0
    ):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.risk_per_trade_pct = risk_per_trade_pct
        self.max_open_positions = max_open_positions
        self.auto_trade_enabled = auto_trade_enabled
        self.min_confidence = min_confidence
        self.point_value = point_value
        
        self.open_trades: List[AutoTrade] = []
        self.closed_trades: List[AutoTrade] = []
        self.daily_trades = 0
        self.daily_pnl = 0.0
        self.max_daily_loss = initial_capital * 0.03
        self.max_trades_per_day = 5
    
    def can_trade(self, confidence: float, regime: str) -> bool:
        """Verifica se puÃ² tradare"""
        if not self.auto_trade_enabled:
            return False
        if confidence < self.min_confidence:
            return False
        if len(self.open_trades) >= self.max_open_positions:
            return False
        if self.daily_trades >= self.max_trades_per_day:
            return False
        if self.daily_pnl < -self.max_daily_loss:
            return False
        if regime == "TRANSITIONING":
            return False
        return True
    
    def execute_trade(
        self,
        signal_type: str,
        direction: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float,
        confidence: float,
        timestamp: datetime
    ) -> Optional[AutoTrade]:
        """Esegue trade automaticamente"""
        risk_amount = self.current_capital * (self.risk_per_trade_pct / 100)
        stop_distance = abs(entry_price - stop_loss)
        contracts = max(1, min(int(risk_amount / (stop_distance * self.point_value)), 3))
        
        trade = AutoTrade(
            entry_time=timestamp,
            entry_price=entry_price,
            direction=direction,
            contracts=contracts,
            stop_loss=stop_loss,
            take_profit=take_profit,
            signal_type=signal_type,
            confidence=confidence
        )
        
        self.open_trades.append(trade)
        self.daily_trades += 1
        
        print(f"\nðŸš€ AUTO-TRADE: {direction} {contracts} @ {entry_price:.2f}")
        print(f"   Stop: {stop_loss:.2f} | Target: {take_profit:.2f}")
        
        return trade
    
    def update_trades(self, price: float, high: float, low: float, timestamp: datetime):
        """Aggiorna trades aperti"""
        to_close = []
        
        for trade in self.open_trades:
            if trade.direction == 'LONG':
                if low <= trade.stop_loss:
                    to_close.append((trade, trade.stop_loss, 'STOP'))
                elif high >= trade.take_profit:
                    to_close.append((trade, trade.take_profit, 'TARGET'))
            else:
                if high >= trade.stop_loss:
                    to_close.append((trade, trade.stop_loss, 'STOP'))
                elif low <= trade.take_profit:
                    to_close.append((trade, trade.take_profit, 'TARGET'))
        
        for trade, exit_price, reason in to_close:
            self.close_trade(trade, exit_price, reason, timestamp)
    
    def close_trade(self, trade: AutoTrade, exit_price: float, reason: str, timestamp: datetime):
        """Chiude trade"""
        points = (exit_price - trade.entry_price) if trade.direction == 'LONG' else (trade.entry_price - exit_price)
        pnl = points * self.point_value * trade.contracts
        
        trade.exit_time = timestamp
        trade.exit_price = exit_price
        trade.exit_reason = reason
        trade.pnl = pnl
        trade.status = TradeStatus.CLOSED
        
        self.current_capital += pnl
        self.daily_pnl += pnl
        self.open_trades.remove(trade)
        self.closed_trades.append(trade)
        
        print(f"ðŸ CLOSED: {reason} @ {exit_price:.2f} | P&L: ${pnl:+.2f}")

# ============================================================================
# FULLY AUTOMATED SYSTEM
# ============================================================================

class FullyAutomatedOrderFlowSystem:
    """Sistema completo automatico ALL-IN-ONE"""
    
    def __init__(
        self,
        initial_capital: float = 10000.0,
        auto_trade_enabled: bool = True
    ):
        self.vwap_system = VWAPSystem()
        self.regime_detector = RegimeDetector(self.vwap_system)
        self.divergence_analyzer = DivergenceAnalyzer()
        self.execution_engine = AutomatedExecutionEngine(
            initial_capital=initial_capital,
            auto_trade_enabled=auto_trade_enabled
        )
    
    def process_tick(
        self,
        timestamp: datetime,
        price: float,
        volume: float,
        cumulative_delta: float,
        high: float,
        low: float
    ):
        """Processa tick - TUTTO AUTOMATICO"""
        
        # Update systems
        self.vwap_system.add_data(timestamp, price, volume)
        self.regime_detector.add_data(price, cumulative_delta)
        self.divergence_analyzer.add_data(timestamp, price, cumulative_delta)
        
        # Detect regime
        regime, regime_conf, reasoning = self.regime_detector.detect_regime()
        
        # Update open trades
        self.execution_engine.update_trades(price, high, low, timestamp)
        
        # Check new signals
        divergences = self.divergence_analyzer.detect_all_divergences()
        
        if divergences:
            div = divergences[0]
            direction = 'LONG' if 'BULLISH' in div.divergence_type.value else 'SHORT'
            
            if self.execution_engine.can_trade(div.confidence, regime.value):
                vwap = self.vwap_system.current_vwap
                stop = div.price_level_2 + (-5 if direction == 'LONG' else 5)
                target = vwap
                
                self.execution_engine.execute_trade(
                    signal_type=div.divergence_type.value,
                    direction=direction,
                    entry_price=price,
                    stop_loss=stop,
                    take_profit=target,
                    confidence=div.confidence,
                    timestamp=timestamp
                )
        
        return regime, reasoning
    
    def get_status(self):
        """Stato sistema"""
        return {
            'capital': self.execution_engine.current_capital,
            'daily_pnl': self.execution_engine.daily_pnl,
            'open_trades': len(self.execution_engine.open_trades),
            'closed_trades': len(self.execution_engine.closed_trades),
            'daily_trades': self.execution_engine.daily_trades
        }

# ============================================================================
# DEMO
# ============================================================================

if __name__ == "__main__":
    print("="*70)
    print("FULLY AUTOMATED ORDER FLOW SYSTEM - ALL IN ONE")
    print("="*70)
    print("\nâœ… Sistema caricato correttamente!")
    print("   - Regime Detection")
    print("   - Divergence Analysis")
    print("   - Automatic Execution")
    print("\nPronto per trading automatico!")
```

### 4. Salva
```

